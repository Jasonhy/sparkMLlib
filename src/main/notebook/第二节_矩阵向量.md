## 概述

MLlib底层的向量,矩阵运算使用了Breeze库,Breeze提供了Vector和Matrix的实现即相应计算接口(Linalg)
但是MLlib里面同时也提供了Vector和Linalg等实现,在MLlib函数里的参数传递均使用MLlib自己的Vector,
而且在函数内的矩阵计算有通过ToBreeze.ToDenseVector变成Breeze的形式进行运算,这样做的目的一是保
证自己的函数接口为稳定性,不会因为Breeze的变化而变化,另外一个就是可以把Distributed Matrix作为一
Matrix的实现而被使用

### ScalaNLP

一套机器学习和数值计算的库,主要是关于科学计算(SC),机器学习(ML)和自然语言处理(NLP),包括三个库:Breeze,
Epic,Puck. Breeze是机器学习和数值计算库,Epic是一种高性能统计分析器和结构化预测库,Puck是一个快速GPU
加速解析器

### Breeze

函数创建:

    scala> import breeze.linalg._
    import breeze.linalg._
    
    scala> import breeze.numerics._
    import breeze.numerics._
    
    创建全0矩阵
    scala> val m1 = DenseMatrix.zeros[Double](2,3)
    m1: breeze.linalg.DenseMatrix[Double] =
    0.0  0.0  0.0
    0.0  0.0  0.0
    
    scala> val v1 = DenseVector.zeros[Double](3)
    v1: breeze.linalg.DenseVector[Double] = DenseVector(0.0, 0.0, 0.0)
    
    scala> val v2 = DenseVector.ones[Double](3)
    v2: breeze.linalg.DenseVector[Double] = DenseVector(1.0, 1.0, 1.0)
    
    按数值填充
    scala> val v3 = DenseVector.fill(3){5.0}
    v3: breeze.linalg.DenseVector[Double] = DenseVector(5.0, 5.0, 5.0)
    
    scala> val v4 = DenseVector.range(1,10,2)
    v4: breeze.linalg.DenseVector[Int] = DenseVector(1, 3, 5, 7, 9)
    
    单位矩阵
    scala> val m2 = DenseMatrix.eye[Double](3)
    m2: breeze.linalg.DenseMatrix[Double] =
    1.0  0.0  0.0
    0.0  1.0  0.0
    0.0  0.0  1.0
    
    对角矩阵
    scala> val v6 = diag(DenseVector(1.0,2.0,3.0))
    v6: breeze.linalg.DenseMatrix[Double] =
    1.0  0.0  0.0
    0.0  2.0  0.0
    0.0  0.0  3.0
    
    scala> val m3 = DenseMatrix((1.0,2.0),(3.0,4.0))
    m3: breeze.linalg.DenseMatrix[Double] =
    1.0  2.0
    3.0  4.0
    
    scala> val v8 = DenseVector(1,2,3,4)
    v8: breeze.linalg.DenseVector[Int] = DenseVector(1, 2, 3, 4)
    
    转置
    scala> v8.t
    res6: breeze.linalg.Transpose[breeze.linalg.DenseVector[Int]] = Transpose(DenseVector(1, 2, 3, 4))
    
    函数中创建
    scala> val v10 = DenseVector.tabulate(3){i => 2*i}
    v10: breeze.linalg.DenseVector[Int] = DenseVector(0, 2, 4)

元素访问及操作函数

    scala> val a = DenseVector[Int](Array(1 to 20 : _*))
    a: breeze.linalg.DenseVector[Int] = DenseVector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)
    
    根据位置选取元素
    scala> a(0)
    res7: Int = 1
    按照范围选取元素
    scala> a(1 to 4)
    res8: breeze.linalg.DenseVector[Int] = DenseVector(2, 3, 4, 5)
    可倒序的选择元素
    scala> a(5 to 0 by -1)
    res9: breeze.linalg.DenseVector[Int] = DenseVector(6, 5, 4, 3, 2, 1)

    创建二维矩阵
    scala> val m = DenseMatrix((1.0,2.0,3.0),(4.0,5.0,6.0))
    m: breeze.linalg.DenseMatrix[Double] =
    1.0  2.0  3.0
    4.0  5.0  6.0
    
    scala> m(0,1)
    res10: Double = 2.0
    获取指定的列
    scala> m(::,1)
    res11: breeze.linalg.DenseVector[Double] = DenseVector(2.0, 5.0)
    改变矩阵形状
    scala> val justAdjustMatrix = m.reshape(3,2)
    justAdjustMatrix: breeze.linalg.DenseMatrix[Double] =
    1.0  5.0
    4.0  3.0
    2.0  6.0
    将矩阵转为向量
    scala> val toVector = m.toDenseVector
    toVector: breeze.linalg.DenseVector[Double] = DenseVector(1.0, 4.0, 2.0, 5.0, 3.0, 6.0)
    
    赋值操作:
    scala> a
    res12: breeze.linalg.DenseVector[Int] = DenseVector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)
    
    scala> a(1 to 4)
    res13: breeze.linalg.DenseVector[Int] = DenseVector(2, 3, 4, 5)
    
    scala> a(1 to 4) := 5
    res14: breeze.linalg.DenseVector[Int] = DenseVector(5, 5, 5, 5)
    
    scala> a(1 to 4) := DenseVector(1,2,3,4)
    res15: breeze.linalg.DenseVector[Int] = DenseVector(1, 2, 3, 4)
    
    scala> m
    res16: breeze.linalg.DenseMatrix[Double] =
    1.0  2.0  3.0
    4.0  5.0  6.0
    
    scala> m(0 to 1,1 to 2) := 0.0
    res17: breeze.linalg.DenseMatrix[Double] =
    0.0  0.0
    0.0  0.0
    
    矩阵连接
    scala> val a1 = DenseMatrix((1.0,2.0,3.0),(4.0,5.0,6.0))
    a1: breeze.linalg.DenseMatrix[Double] =
    1.0  2.0  3.0
    4.0  5.0  6.0
    
    scala> val a2 = DenseMatrix((7.0,8.0,9.0),(10.0,11.0,12.0))
    a2: breeze.linalg.DenseMatrix[Double] =
    7.0   8.0   9.0
    10.0  11.0  12.0
    
    垂直连接
    scala> val verticalLike = DenseMatrix.vertcat(a1,a2)
    verticalLike: breeze.linalg.DenseMatrix[Double] =
    1.0   2.0   3.0
    4.0   5.0   6.0
    7.0   8.0   9.0
    10.0  11.0  12.0
    
    水平连接
    scala> val twoMatrixConn = DenseMatrix.horzcat(a1,a2)
    twoMatrixConn: breeze.linalg.DenseMatrix[Double] =
    1.0  2.0  3.0  7.0   8.0   9.0
    4.0  5.0  6.0  10.0  11.0  12.0
    
    运算
    scala> a1 + a2
    res18: breeze.linalg.DenseMatrix[Double] =
    8.0   10.0  12.0
    14.0  16.0  18.0
    
    scala> a1 :* a2
    warning: there was one deprecation warning; re-run with -deprecation for details
    res22: breeze.linalg.DenseMatrix[Double] =
    7.0   16.0  27.0
    40.0  55.0  72.0
    
    scala> a1 :< a2
    warning: there was one deprecation warning; re-run with -deprecation for details
    res23: breeze.linalg.DenseMatrix[Boolean] =
    true  true  true
    true  true  true
    
    元素追加
    scala> a1 :+= 2.0
    res24: breeze.linalg.DenseMatrix[Double] =
    3.0  4.0  5.0
    6.0  7.0  8.0
   
    scala> a1 :*= 2.0
    res26: breeze.linalg.DenseMatrix[Double] =
    6.0   8.0   10.0
    12.0  14.0  16.0
    
    点积:
    scala> val vectorDot = DenseVector(1,2,3,4) dot DenseVector(1,1,1,1)
    vectorDot: Int = 10
    
    最值:
    scala> max(a1)
    res27: Double = 16.0

    求和:
    scala> val m1 = DenseMatrix((1.0,2.0,3.0,4.0),(5.0,6.0,7.0,8.0),(9.0,10.0,11.0,12.0))
    m1: breeze.linalg.DenseMatrix[Double] =
    1.0  2.0   3.0   4.0
    5.0  6.0   7.0   8.0
    9.0  10.0  11.0  12.0
    
    scala> sum(m1)
    res28: Double = 78.0
    列求和
    scala> sum(m1,Axis._0)
    res29: breeze.linalg.Transpose[breeze.linalg.DenseVector[Double]] = Transpose(DenseVector(15.0, 18.0, 21.0, 24.0))
    行求和
    scala> sum(m1,Axis._1)
    res30: breeze.linalg.DenseVector[Double] = DenseVector(10.0, 26.0, 42.0)

    对角线和:
    scala> m1
    res31: breeze.linalg.DenseMatrix[Double] =
    1.0  2.0   3.0   4.0
    5.0  6.0   7.0   8.0
    9.0  10.0  11.0  12.0
    
    scala> val lt = lowerTriangular(m1)
    lt: breeze.linalg.DenseMatrix[Double] =
    1.0  0.0   0.0
    5.0  6.0   0.0
    9.0  10.0  11.0
    
    scala> trace(lt)
    res34: Double = 18.0
    
    累加:
    scala> accumulate(m1.toDenseVector)
    res43: breeze.linalg.DenseVector[Double] = DenseVector(1.0, 6.0, 15.0, 17.0, 23.0, 33.0, 36.0, 43.0, 54.0, 58.0, 66.0, 78.0)
    
    布尔函数
    scala> val c = DenseVector(true,false,true)
    c: breeze.linalg.DenseVector[Boolean] = DenseVector(true, false, true)
    
    scala> val d = DenseVector(false,true,true)
    d: breeze.linalg.DenseVector[Boolean] = DenseVector(false, true, true)
    
    scala> c :& d
    warning: there was one deprecation warning; re-run with -deprecation for details
    res44: breeze.linalg.DenseVector[Boolean] = DenseVector(false, false, true)
    
    scala> c :| d
    warning: there was one deprecation warning; re-run with -deprecation for details
    res45: breeze.linalg.DenseVector[Boolean] = DenseVector(true, true, true)
    
    scala> !c
    res46: breeze.linalg.DenseVector[Boolean] = DenseVector(false, true, false)
    
    零元素
    scala> val e = DenseVector[Int](-3,0,2)
    e: breeze.linalg.DenseVector[Int] = DenseVector(-3, 0, 2)
    是否存在零元素
    scala> any(e)
    res47: Boolean = true
    是否都是零元素
    scala> all(e)
    res48: Boolean = false
    
    线性代数函数
    scala> val f = DenseMatrix((1.0,2.0,3.0),(4.0,5.0,6.0),(7.0,8.0,9.0))
    f: breeze.linalg.DenseMatrix[Double] =
    1.0  2.0  3.0
    4.0  5.0  6.0
    7.0  8.0  9.0
    
    scala> val g = DenseMatrix((1.0,1.0,1.0),(1.0,1.0,1.0),(1.0,1.0,1.0))
    g: breeze.linalg.DenseMatrix[Double] =
    1.0  1.0  1.0
    1.0  1.0  1.0
    1.0  1.0  1.0
    线性求解: AX = B,求解X
    scala> f \ g
    res49: breeze.linalg.DenseMatrix[Double] =
    -2.5  -2.5  -2.5
    4.0   4.0   4.0
    -1.5  -1.5  -1.5
    
    求特征值
    scala> det(f)
    res50: Double = 6.661338147750939E-16
    求逆
    scala> inv(f)
    res51: breeze.linalg.DenseMatrix[Double] =
    -4.503599627370499E15  9.007199254740992E15    -4.503599627370495E15
    9.007199254740998E15   -1.8014398509481984E16  9.007199254740991E15
    -4.503599627370498E15  9.007199254740992E15    -4.5035996273704955E15
    求伪逆
    scala> pinv(f)
    res52: breeze.linalg.DenseMatrix[Double] =
    -3.7720834019330525E14  7.544166803866101E14    -3.77208340193305E14
    7.544166803866094E14    -1.5088333607732208E15  7.544166803866108E14
    -3.772083401933041E14   7.544166803866104E14    -3.772083401933055E14
    特征值和特征向量
    scala> eig(f)
    res53: breeze.linalg.eig.DenseEig =
    Eig(DenseVector(16.116843969807043, -1.1168439698070427, -1.3036777264747022E-15),DenseVector(0.0, 0.0, 0.0),-0.23197068724628617  -0.7858302387420671   0.40824829046386363
    -0.5253220933012336   -0.08675133925662833  -0.816496580927726
    -0.8186734993561815   0.61232756022881      0.4082482904638625   )
    奇异值分解
    scala> val svd.SVD(u,s,v) = svd(g)
    u: breeze.linalg.DenseMatrix[Double] =
    -0.5773502691896255  -0.5773502691896257  -0.5773502691896256
    -0.5773502691896256  -0.2113248654051871  0.7886751345948126
    -0.5773502691896256  0.7886751345948129   -0.21132486540518708
    s: breeze.linalg.DenseVector[Double] = DenseVector(3.0000000000000004, 0.0, 0.0)
    v: breeze.linalg.DenseMatrix[Double] =
    -0.5773502691896256  -0.5773502691896257  -0.5773502691896256
    0.0                  -0.7071067811865474  0.7071067811865477
    0.816496580927726    -0.4082482904638629  -0.4082482904638628

### BLAS(基础线性代数程序集)

一个应用程序接口(API)标准,用以规范发布基础线性代数操作的数值库(如向量或矩阵乘法)

按功能分为三个级别:

    Level1: 向量-向量运算,比如点积(ddot),加法和数乘(daxpy),绝对值的和(dasum)等
                y <- αx + y
    Level2: 矩阵-向量运算,最重要的函数是一般的矩阵向量乘法(dgemv)
                y <- αAx + βy
    Level3: 矩阵-矩阵运算,最重要的函数一般的矩阵乘法(dgemm)
                X <- αAB + βC

### 分布式矩阵

分布式矩阵的数据分块或者分行存储,并且实现了矩阵的基本运算,能够使矩阵分布式计算,比如统计,相似度,协方差,
奇异值分解等

包括:

    RowMatrix,IndexedRowMatrix,CoordinateMatrix,BlockMatrix
    
#### 行矩阵(RowMatrix)

每行对应的是一个RDD,将每行进行分布式存储,每行是一个本地向量

newRowMatrix: 创建RowMatrix的方法

    参数:
        rows: 为向量RDD,每一行为一个向量,对应矩阵的一行
        nRows: 矩阵行数
        cCols: 矩阵列数
        
    示例:
        
        scala> import org.apache.spark.mllib.linalg.distributed._
        import org.apache.spark.mllib.linalg.distributed._
        
        scala> import org.apache.spark.mllib.linalg._
        import org.apache.spark.mllib.linalg._
        
        scala> val rdd1 = sc.parallelize(Array(Array(1.0,2.0,3.0,4.0),Array(2.0,3.0,4.0,5.0),Array(3.0,4.0,5.0,6.0))).map(f => Vectors.dense(f))
        rdd1: org.apache.spark.rdd.RDD[org.apache.spark.mllib.linalg.Vector] = MapPartitionsRDD[10] at map at <console>:41
        
        scala> val RM = new RowMatrix(rdd1)
        RM: org.apache.spark.mllib.linalg.distributed.RowMatrix = org.apache.spark.mllib.linalg.distributed.RowMatrix@40f88c3a

columnSimilarities: 计算每列之间的相似度,采用抽样的方法进行计算
      
    示例:
        scala> val simic1 = RM.columnSimilarities(0.5)
        simic1: org.apache.spark.mllib.linalg.distributed.CoordinateMatrix = org.apache.spark.mllib.linalg.distributed.CoordinateMatrix@7f344790

computeColumnSummaryStatistcs: 每列的汇总统计

    示例:
        scala> val simic2 = RM.computeColumnSummaryStatistics()
        simic2: org.apache.spark.mllib.stat.MultivariateStatisticalSummary = org.apache.spark.mllib.stat.MultivariateOnlineSummarizer@230ce9fa
        
        scala> simic2.max
        res56: org.apache.spark.mllib.linalg.Vector = [3.0,4.0,5.0,6.0]
        
        scala> simic2.min
        res57: org.apache.spark.mllib.linalg.Vector = [1.0,2.0,3.0,4.0]
            
computeCovariance: 计算每列之间的协方差,生成协方差矩阵

    示例:
          scala> val cc1 = RM.computeCovariance
          cc1: org.apache.spark.mllib.linalg.Matrix =
          1.0  1.0  1.0  1.0
          1.0  1.0  1.0  1.0
          1.0  1.0  1.0  1.0
          1.0  1.0  1.0  1.0
              
computeGramianMatrix: 计算格拉姆矩阵       

    示例:
        scala> RM.computeGramianMatrix
        res58: org.apache.spark.mllib.linalg.Matrix =
        14.0  20.0  26.0  32.0
        20.0  29.0  38.0  47.0
        26.0  38.0  50.0  62.0
        32.0  47.0  62.0  77.0
            
computePrincipalComponent(k:Int): 主成分分析

    去前k个主要变量,其结果矩阵的行为样本,列为变量           
    示例:
        scala> val pc1 = RM.computePrincipalComponents(3)
        pc1: org.apache.spark.mllib.linalg.Matrix =
        -0.5000000000000002  0.8660254037844388    1.6653345369377348E-16
        -0.5000000000000002  -0.28867513459481275  0.8164965809277258
        -0.5000000000000002  -0.28867513459481287  -0.40824829046386296
        -0.5000000000000002  -0.28867513459481287  -0.40824829046386296
        
computeSVD: 计算奇异值分解

    示例:
        scala> val svd = RM.computeSVD(4,true)
        svd: org.apache.spark.mllib.linalg.SingularValueDecomposition[org.apache.spark.mllib.linalg.distributed.RowMatrix,org.apache.spark.mllib.linalg.Matrix] =
        SingularValueDecomposition(org.apache.spark.mllib.linalg.distributed.RowMatrix@4519b914,[13.011193721236575,0.8419251442105343,7.793650306633694E-8,5.761418127495863E-8],-0.2830233037672786  -0.7873358937103356  -0.5230588083704528  0.1625099473450276
        -0.4132328277901395  -0.3594977469144485  0.5762839813994665   -0.6065449470421622
        -0.5434423518130005  0.06834039988143598  0.41660846231241616  0.7255600520492322
        -0.6736518758358616  0.4961785466773299   -0.4698336353414315  -0.28152505235209946  )
        
        scala> svd.U
        res60: org.apache.spark.mllib.linalg.distributed.RowMatrix = org.apache.spark.mllib.linalg.distributed.RowMatrix@4519b914
        
        scala> svd.s
        res61: org.apache.spark.mllib.linalg.Vector = [13.011193721236575,0.8419251442105343,7.793650306633694E-8,5.761418127495863E-8]
        
        scala> svd.V
        res62: org.apache.spark.mllib.linalg.Matrix =
        -0.2830233037672786  -0.7873358937103356  -0.5230588083704528  0.1625099473450276
        -0.4132328277901395  -0.3594977469144485  0.5762839813994665   -0.6065449470421622
        -0.5434423518130005  0.06834039988143598  0.41660846231241616  0.7255600520492322
        -0.6736518758358616  0.4961785466773299   -0.4698336353414315  -0.28152505235209946

multiply: 矩阵乘法,右乘运算

#### 行索引矩阵(IndexedRowMatrix)

与RowMatrix的区别是它带有一定意义的行索引,在RowMatrix中,rows的格式是RDD[Vector],而在IndexedRowMatrix中,rows的
格式是RDD[IndexedRow],其中IndexedRow的是格式是(index: Long,vector: Vector)

IndexedRowMatrix: 创建行索引矩阵

    参数:
        rows: 为IndexedRow格式的RDD,对应矩阵的一行
        nRows: 矩阵行数
        nCols: 矩阵列数
        
#### CoordinateMatrix: 坐标矩阵

每一项都是一个(i:Long,j:Long,value:Double)指示行列值的元组tuple,其中i是行坐标,j是列坐标,value是值,如果矩阵是非常大的
而且稀疏,则坐标矩阵一定是最好的选择,通过RDD[MatrixEntry]实例创建,MatrixEntry为(long,long,Double)形式,坐标矩阵可以转
化为IndexedRowMatrix

    参数:
        entris: 为MatrixEntry格式RDD,格式为(行坐标,列坐标,值),对应矩阵的一个元素
        nRows: 矩阵行数
        nCols: 矩阵列数

#### BlockMatrix: 分块矩阵

指的是将矩阵分割出较小的矩形矩阵,这些较小的矩阵就被称为区块,换一个说法就是,以较小的矩阵组合成一个矩阵,分块矩阵
的分割原则是以水平线和垂直线进行划分的,在分块矩阵中位于同一行(列)的每一个子矩阵,都拥有相同的列数(行数)

BlockMatrix是以blocks块存储,blocks的格式为RDD[((blockRowIndex,blockColIndex),sub-matrix)],其中blockRowIndex
是block块行索引,blockColIndex块列索引,sub-matrix是block块矩阵

